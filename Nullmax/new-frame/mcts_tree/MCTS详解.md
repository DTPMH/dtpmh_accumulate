<center><span style="font-size:2rem;font-weight:bold;">MCTS详解</span></center>

<div style="page-break-after: always;"></div>

[toc]

<div style="page-break-after: always;"></div>

---

## 🌲 一、MCTS 是什么？

**MCTS（蒙特卡洛树搜索）** 是一种通过**随机模拟**（Monte Carlo）和**树状决策搜索**（Tree Search）结合的算法。

它的目标是：

> 在一个巨大的决策空间（比如游戏、路径规划、机器人动作选择）中，找到最优的行动策略。

它特别适合：

* 分支极多、搜索空间极大的问题（如围棋、国际象棋、路径规划）
* 模型复杂、但可以模拟（rollout）评估结果的任务

---

## 🧩 二、核心思想

MCTS 不需要完整搜索整棵树。
它通过**不断模拟和更新一小部分节点的统计信息**，逐步逼近最优解。

换句话说，它就是：

> “边玩边学”
> 每次随机玩到终局，然后根据输赢来调整策略。

---

## 🧠 三、算法四个核心阶段

MCTS 的每一次搜索迭代包含 **4 个阶段**：

### 1️⃣ Selection（选择阶段）

从根节点开始，根据当前的统计信息，不断选择“最有潜力”的子节点，直到到达一个 **未完全展开** 的节点。

使用的公式是著名的：

### 📘 UCT (Upper Confidence Bound for Trees)

$$
UCB = Q_i + c \sqrt{\frac{\ln N}{n_i}}
$$

* ( Q_i )：节点平均收益（exploit）
* ( N )：父节点访问次数
* ( n_i )：当前节点访问次数
* ( c )：探索系数（exploration）

📌 意思是：

> 既要选看起来最优的（高 Q），又要给没怎么探索过的机会（高 uncertainty）。

---

### 2️⃣ Expansion（扩展阶段）

到达一个还没被探索过的节点（比如一个新的棋步），创建它的子节点（即新状态）。

---

### 3️⃣ Simulation（模拟阶段）

从新节点开始，**随机模拟（Rollout）**，直到游戏结束或达到终止条件。
这一步不搜索，只是随机玩一局，看最后结果是赢还是输。

---

### 4️⃣ Backpropagation（回溯阶段）

把刚才那次模拟的结果（胜负、得分）沿着路径**往上更新**。
每个节点都会记录：

* 访问次数 ( n_i )
* 总得分 ( w_i )
* 平均收益 ( Q_i = w_i / n_i )

这样，整个树的统计信息就逐渐逼近真实价值。

---

## 🔁 四、MCTS 的循环流程

重复以上 4 步（Selection → Expansion → Simulation → Backpropagation），每次都会让树更聪明一点。

经过多次迭代后，根节点的子节点中：

* 访问次数最多的那个
* 或平均价值最高的那个

就是当前最优决策。

---

## 🧮 五、伪代码（简化版）

```python
def MCTS(root):
    for i in range(num_iterations):
        node = select(root)
        if not node.fully_expanded():
            node = expand(node)
        result = simulate(node)
        backpropagate(node, result)
    return best_child(root)
```

---

## 🎯 六、一个直观例子：井字棋（Tic-Tac-Toe）

1️⃣ 根节点 = 当前棋盘
2️⃣ 子节点 = 不同的下一步落子方案
3️⃣ 模拟 = 从这个局面开始随机下完
4️⃣ 回溯 = 如果赢了，路径上的节点得分 +1，否则 0

迭代几百次后，算法能自动学到：

> 哪一步落子赢面最大。

---

## 🧠 七、优缺点总结

| 优点                                       | 缺点                       |
| ------------------------------------------ | -------------------------- |
| ✅ 不需要完整模型或评估函数，只要能模拟结果 | ❌ 模拟耗时大               |
| ✅ 可随时中断（随时给出当前最优解）         | ❌ 随机模拟质量影响效果     |
| ✅ 对复杂、非确定性问题有效                 | ❌ 难以在高维连续空间中应用 |

---

## 🌟 八、实际应用

| 领域         | 应用                                |
| ------------ | ----------------------------------- |
| 🎮 游戏 AI    | AlphaGo、国际象棋、井字棋等         |
| 🚗 自动驾驶   | 路径规划、行为决策（选择变道/超车） |
| 🤖 机器人控制 | 规划多步动作                        |
| 🎯 优化       | 调度、组合优化问题                  |

---

## 🧭 九、形象比喻

想象你要在一座迷宫中找出口：

* **Selection**：根据以往经验挑选最可能的路口
* **Expansion**：发现一个新岔路口，去探索
* **Simulation**：随机走下去看能不能出去
* **Backpropagation**：如果走通了，记录这条路线的“好评”
* **循环几千次**后，你就知道哪条路最靠谱。

---

## 🔍 十、可视化图示（结构）

```
         [Root]
          / | \
         /  |  \
   [Move1] [Move2] [Move3]
      |         \
 [Child1]      [Child2]
      |
  [Leaf Node] ← Expand + Simulate
```

---

如果你愿意，我可以帮你：

* ✅ 画一张 **MCTS 搜索过程的动态图**（展示选择→扩展→模拟→回溯）
* ✅ 或者提供一个 **C++ 可视化程序**（在控制台上逐步显示节点扩展）

你更希望我用哪种方式展示？
🖼️ 图形动画（matplotlib 或 SFML）
💻 控制台动态文本（C++ 输出树形过程）